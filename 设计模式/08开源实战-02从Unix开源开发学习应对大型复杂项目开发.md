### 从Unix开源开发学习应对大型复杂项目开发

#### 从设计原则和思想的角度看

- __封装与抽象__

  在 Unix、Linux 系统中，很多东西都被抽象成“文件”这样一个概念，它们使用文件系统的路径作为统一的命名空间（namespace），使用统一的 read、write 标准函数来访问。

  封装了不同类型设备的访问细节，抽象为统一的文件访问方式，更高层的代码就能基于统一的访问方式，来访问底层不同类型的设备。

  将复杂性封装在局部代码中，隔离实现的易变性，提供简单、统一的访问接口。

- __分层与模块化__

  Unix 系统大致上分为三层，分别是内核、系统调用、应用层。

  每一层都对上层封装实现细节，暴露抽象的接口来调用。而且，任意一层都可以被重新实现，不会影响到其他层的代码。

  把容易复用、跟具体业务关系不大的代码，尽量下沉到下层，把容易变动、跟具体业务强相关的代码，尽量上移到上层。

- __基于接口通信__

  在设计模块（module）或者层（layer）要暴露的接口的时候，要学会隐藏实现，接口从命名到定义都要抽象一些，尽量少涉及具体的实现细节。

  Unix 系统提供的 open() 文件操作函数，底层实现非常复杂，涉及权限控制、并发控制、物理存储等，使用却很简单。因为 open() 函数基于抽象而非具体的实现来定义，所以我们在改动 open() 函数的底层实现的时候，并不需要改动依赖它的上层代码。

- __高内聚、松耦合__

  封装、抽象、分层、模块化、基于接口通信，都能有效地实现代码的高内聚、松耦合。反过来，代码的高内聚、松耦合，也就意味着，抽象、封装做到比较到位、代码结构清晰、分层和模块化合理、依赖关系简单，那代码整体的质量就不会太差。

- __为扩展而设计__

  代码满足开闭原则，基于扩展而非修改来添加新功能，最小化、集中化代码改动，避免新代码影响到老代码，降低引入 bug 的风险。

  识别出代码可变部分和不可变部分，将可变部分封装起来，隔离变化，提供抽象化的不可变接口，供上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。

- __KISS 首要原则__

  参与大型项目开发的时候，要尽量避免过度设计、过早优化，在扩展性和可读性有冲突的时候，或者在两者之间权衡，模棱两可的时候，应该选择遵循 KISS 原则，首选可读性。

- __最小惊奇原则__

  在做设计或者编码的时候要遵守统一的开发规范，避免反直觉的设计。

#### 从研发管理和开发技巧的角度来看

- __吹毛求疵般地执行编码规范__

- __编写高质量的单元测试__
- __不流于形式的 Code Review__
- __开发未动、文档先行__
- __持续重构、重构、重构__
- __对项目与团队进行拆分__

#### 从 Code Review 上来看

- __Code Review的价值__
  - Code Review 践行“三人行必有我师”
  - Code Review 能摒弃“个人英雄主义”
  - Code Review 能有效提高代码可读性
  - Code Review 是技术传帮带的有效途径
  - Code Review 保证代码不止一个人熟悉
  - Code Review 能打造良好的技术氛围
  - Code Review 是一种技术沟通方式
  - Code Review 能提高团队的自律性

- __如何落地执行 Code Review？__
  - 工期排松，Code Review熟练之后可以很快做完。
  - 资深同事、技术好的同事或技术 leader，来 Review 其他所有人的代码。
  - 将 Code Review 间接地跟 KPI、升职等联系在一块，鼓励执行Code Review。

